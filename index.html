<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>FBX Model with 3rd Person Controls, Running, Jump & Grass Plane</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    /* Dark loading screen with smooth green progress bar */
    #loadingContainer {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: #000; /* dark background */
      display: flex; 
      justify-content: center; 
      align-items: center;
      z-index: 9999;
      flex-direction: column;
      font-family: sans-serif;
      color: #fff;
    }
    #progressBarContainer {
      width: 300px;
      height: 20px;
      background-color: #333;
      margin-top: 10px;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background-color: #00ff00; /* green progress */
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loadingContainer">
    <div>Loading...</div>
    <div id="progressBarContainer">
      <div id="progressBar"></div>
    </div>
  </div>

  <!--
    NOTES:
    - Include fflate.min.js before loaders like FBXLoader if needed for decompression.
    - Load Three.js and loaders (FBXLoader, GLTFLoader) from reliable CDNs.
  -->
  <script src="https://unpkg.com/fflate@0.7.1/umd/index.js"></script>
  <script src="https://unpkg.com/three@0.134.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/FBXLoader.js"></script>
  <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Optional: SkeletonUtils if you need retargeting -->
  <script src="https://unpkg.com/three@0.134.0/examples/js/utils/SkeletonUtils.js"></script>
  <script>
    // TRACK LOADING PROGRESS (Grass texture + 3 FBX assets + Tree model)
    let resourcesToLoad = 5;
    let resourcesLoaded = 0;
    function resourceLoaded() {
      resourcesLoaded++;
      updateProgress();
    }
    function updateProgress() {
      let progress = (resourcesLoaded / resourcesToLoad) * 100;
      document.getElementById('progressBar').style.width = progress + '%';
      if (resourcesLoaded === resourcesToLoad) {
        document.getElementById('loadingContainer').style.display = 'none';
      }
    }

    // SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    
    const camera = new THREE.PerspectiveCamera(
      75, 
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    // LIGHTS
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);
    
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemiLight.position.set(0, 200, 0);
    scene.add(hemiLight);
    
    const pointLight = new THREE.PointLight(0xffffff, 0.8);
    pointLight.position.set(0, 10, 0);
    scene.add(pointLight);

    // PLAYER & ANIMATION VARIABLES
    let player = null;
    let mixer = null;
    let idleAction, runAction, jumpAction, activeAction;
    let isJumping = false;
    let jumpSwitchTriggered = false;
    
    // MOVEMENT CONTROLS (WASD, Arrow Keys, Shift for run)
    const keys = { 
      w: false, a: false, s: false, d: false, 
      up: false, down: false, left: false, right: false,
      shift: false 
    };
    const moveSpeed = 5; // base movement speed
    
    // CAMERA & CHARACTER ROTATION VARIABLES
    let autoYaw = 0;
    let manualYawOffset = 0;
    let cameraPitch = 0.3;     
    let cameraDistance = 10;   
    const cameraHeight = 5;
    
    // MOUSE CONTROL VARIABLES
    let isRightMouseDown = false;
    let isLeftMouseDown = false;
    let previousMousePosition = { x: 0, y: 0 };
    
    // MOUSE EVENTS
    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button === 2) { // Right mouse button: mouselook & rotate character
        isRightMouseDown = true;
        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
      } else if (event.button === 0) { // Left mouse button: used for special forward movement
        isLeftMouseDown = true;
      }
    });
    
    renderer.domElement.addEventListener('mousemove', (event) => {
      if (isRightMouseDown) {
        let deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y
        };
        const sensitivity = 0.005;
        // Update manual yaw offset without affecting autoYaw
        manualYawOffset -= deltaMove.x * sensitivity;
        // Invert vertical movement for pitch
        cameraPitch += deltaMove.y * sensitivity;
        cameraPitch = Math.max(-0.5, Math.min(0.8, cameraPitch));
        previousMousePosition.x = event.clientX;
        previousMousePosition.y = event.clientY;
      }
    });
    
    renderer.domElement.addEventListener('mouseup', (event) => {
      if (event.button === 2) {
        isRightMouseDown = false;
      } else if (event.button === 0) {
        isLeftMouseDown = false;
      }
    });
    
    // Disable context menu on right-click
    document.addEventListener('contextmenu', (evt) => {
      evt.preventDefault();
    });
    
    // CAMERA ZOOM WITH MOUSE WHEEL
    window.addEventListener('wheel', (event) => {
      cameraDistance += event.deltaY * 0.01;
      cameraDistance = Math.max(5, Math.min(20, cameraDistance));
    });
    
    // KEYBOARD INPUT
    document.addEventListener('keydown', (event) => {
      switch(event.code) {
        case 'KeyW': keys.w = true; break;
        case 'KeyA': keys.a = true; break;
        case 'KeyS': keys.s = true; break;
        case 'KeyD': keys.d = true; break;
        case 'ArrowUp': keys.up = true; break;
        case 'ArrowDown': keys.down = true; break;
        case 'ArrowLeft': keys.left = true; break;
        case 'ArrowRight': keys.right = true; break;
        case 'ShiftLeft':
        case 'ShiftRight': keys.shift = true; break;
        case 'Space':
          if (!isJumping && jumpAction) {
            isJumping = true;
            jumpSwitchTriggered = false;
            switchAction(jumpAction, 0);
          }
          break;
      }
    });
    
    document.addEventListener('keyup', (event) => {
      switch(event.code) {
        case 'KeyW': keys.w = false; break;
        case 'KeyA': keys.a = false; break;
        case 'KeyS': keys.s = false; break;
        case 'KeyD': keys.d = false; break;
        case 'ArrowUp': keys.up = false; break;
        case 'ArrowDown': keys.down = false; break;
        case 'ArrowLeft': keys.left = false; break;
        case 'ArrowRight': keys.right = false; break;
        case 'ShiftLeft':
        case 'ShiftRight': keys.shift = false; break;
      }
    });
    
    /**
     * Switch animations with optional crossfade duration.
     * @param {THREE.AnimationAction} newAction
     * @param {number} [fadeDuration=0]
     */
    function switchAction(newAction, fadeDuration = 0) {
      if (activeAction === newAction) return;
      newAction.reset().play();
      if (activeAction) {
        activeAction.crossFadeTo(newAction, fadeDuration, false);
      }
      activeAction = newAction;
    }
    
    // TEXTURE LOADER FOR GRASS
    const textureLoader = new THREE.TextureLoader();
    const grassTexture = textureLoader.load(
      'https://threejs.org/examples/textures/terrain/grasslight-big.jpg',
      () => { resourceLoaded(); }
    );
    grassTexture.wrapS = THREE.RepeatWrapping;
    grassTexture.wrapT = THREE.RepeatWrapping;
    grassTexture.repeat.set(50, 50);
    
    const planeMaterial = new THREE.MeshStandardMaterial({
      map: grassTexture,
      color: new THREE.Color(0x556b2f)
    });
    const planeGeometry = new THREE.PlaneGeometry(500, 500);
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    plane.position.y = -1;
    scene.add(plane);
    
    // LOAD FBX MODELS
    const fbxLoader = new THREE.FBXLoader();
    
    // 1) LOAD THE IDLE FBX MODEL (Player)
    fbxLoader.load(
      'https://raw.githubusercontent.com/NoLimitNexus/Utilities/main/Idle.fbx',
      function (object) {
        player = object;
        player.scale.set(0.01, 0.01, 0.01);
        player.position.set(0, -1, 0);
        scene.add(player);
        
        mixer = new THREE.AnimationMixer(player);
        if (object.animations && object.animations.length > 0) {
          idleAction = mixer.clipAction(object.animations[0]);
          idleAction.play();
          activeAction = idleAction;
        } else {
          console.log('No idle animations found');
        }
        resourceLoaded();
        
        // 2) LOAD THE RUNNING ANIMATION
        fbxLoader.load(
          'https://raw.githubusercontent.com/NoLimitNexus/Utilities/main/Running.fbx',
          function (runObject) {
            if (runObject.animations && runObject.animations.length > 0) {
              let runClip = runObject.animations[0];
              runClip.tracks.forEach(track => {
                if (track.name.startsWith('mixamorig:')) {
                  track.name = track.name.replace('mixamorig:', '');
                }
              });
              runAction = mixer.clipAction(runClip);
              runAction.setLoop(THREE.LoopRepeat);
            } else {
              console.log('No running animations found');
            }
            resourceLoaded();
          },
          function (xhr) {
            console.log('Running animation: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
          },
          function (error) {
            console.error('Error loading running animation:', error);
          }
        );
        
        // 3) LOAD THE JUMP ANIMATION
        fbxLoader.load(
          'https://raw.githubusercontent.com/NoLimitNexus/Utilities/main/Jump.fbx',
          function (jumpObject) {
            if (jumpObject.animations && jumpObject.animations.length > 0) {
              let jumpClip = jumpObject.animations[0];
              jumpClip.tracks.forEach(track => {
                if (track.name.startsWith('mixamorig:')) {
                  track.name = track.name.replace('mixamorig:', '');
                }
              });
              jumpAction = mixer.clipAction(jumpClip);
              jumpAction.setLoop(THREE.LoopOnce);
              jumpAction.clampWhenFinished = false;
            } else {
              console.log('No jump animations found');
            }
            resourceLoaded();
          },
          function (xhr) {
            console.log('Jump animation: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
          },
          function (error) {
            console.error('Error loading jump animation:', error);
          }
        );
      },
      function (xhr) {
        console.log('Idle model: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
      },
      function (error) {
        console.error('Error loading idle model:', error);
      }
    );

    // 4) LOAD THE TREE MODEL USING GLTF LOADER AND PLACE MULTIPLE TREES
    const gltfLoader = new THREE.GLTFLoader();
    gltfLoader.load(
      'https://raw.githack.com/NoLimitNexus/Utilities/refs/heads/main/Tree.glb',
      function (gltf) {
        // Get the tree model from the loaded GLTF scene
        const treeModel = gltf.scene;
        // Scale the tree (5x bigger than the original 0.05 scale)
        treeModel.scale.set(0.25, 0.25, 0.25);
        const numTrees = 50;
        for (let i = 0; i < numTrees; i++) {
          let pos;
          // Ensure the tree is not placed too close to the player's starting position (0, -1, 0)
          do {
            pos = new THREE.Vector3(
              THREE.MathUtils.randFloatSpread(500),
              -1,
              THREE.MathUtils.randFloatSpread(500)
            );
          } while (pos.distanceTo(new THREE.Vector3(0, -1, 0)) < 50);
          const treeClone = treeModel.clone();
          treeClone.position.copy(pos);
          scene.add(treeClone);
        }
        resourceLoaded();
      },
      function (xhr) {
        console.log('Tree model: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
      },
      function (error) {
        console.error('Error loading tree model:', error);
        resourceLoaded();
      }
    );
    
    // ANIMATION & RENDER LOOP
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      
      if (mixer) mixer.update(delta);
      
      if (player) {
        // --- ROTATION HANDLING ---
        const turnSpeed = 2.0;
        if (keys.left) {
          manualYawOffset -= turnSpeed * delta;
        }
        if (keys.right) {
          manualYawOffset += turnSpeed * delta;
        }
        
        let finalYaw = autoYaw + manualYawOffset;
        
        const forwardVec = new THREE.Vector3(Math.sin(finalYaw), 0, Math.cos(finalYaw));
        const rightVec   = new THREE.Vector3(Math.sin(finalYaw - Math.PI / 2), 0, Math.cos(finalYaw - Math.PI / 2));
        let movement = new THREE.Vector3();
        
        if (keys.w || keys.up) movement.add(forwardVec);
        if (keys.s || keys.down) movement.sub(forwardVec);
        if (keys.a) movement.sub(rightVec);
        if (keys.d) movement.add(rightVec);
        if (isLeftMouseDown && isRightMouseDown) {
          movement.add(forwardVec);
        }
        
        if (Math.abs(manualYawOffset) < 0.001 && movement.length() > 0) {
          movement.normalize();
          let targetYaw = Math.atan2(movement.x, movement.z);
          let yawDiff = targetYaw - autoYaw;
          yawDiff = (yawDiff + Math.PI) % (2 * Math.PI) - Math.PI;
          const autoTurnSpeed = 4.0;
          let maxTurn = autoTurnSpeed * delta;
          if (Math.abs(yawDiff) < maxTurn) {
            autoYaw = targetYaw;
          } else {
            autoYaw += Math.sign(yawDiff) * maxTurn;
          }
          finalYaw = autoYaw;
        }
        
        player.rotation.y = finalYaw;
        
        if (movement.length() > 0) {
          movement.normalize();
          const speed = keys.shift ? moveSpeed * 2 : moveSpeed;
          player.position.add(movement.multiplyScalar(speed * delta));
        }
        
        // --- CAMERA POSITIONING ---
        const offsetX = Math.sin(finalYaw) * cameraDistance * Math.cos(cameraPitch);
        const offsetZ = Math.cos(finalYaw) * cameraDistance * Math.cos(cameraPitch);
        const offsetY = cameraHeight + cameraDistance * Math.sin(cameraPitch);
        camera.position.set(
          player.position.x - offsetX,
          player.position.y + offsetY,
          player.position.z - offsetZ
        );
        camera.lookAt(player.position.x, player.position.y + 2, player.position.z);
        
        // --- JUMP ANIMATION HANDLING ---
        if (isJumping && activeAction === jumpAction && jumpAction.getClip()) {
          const jumpDuration = jumpAction.getClip().duration;
          if (!jumpSwitchTriggered && jumpAction.time >= jumpDuration - 0.1) {
            jumpSwitchTriggered = true;
            isJumping = false;
            switchAction((movement.length() > 0 ? runAction : idleAction), 0.1);
          }
        }
        if (!isJumping && runAction && idleAction) {
          if (movement.length() > 0 && activeAction !== runAction) {
            switchAction(runAction, 0);
          } else if (movement.length() === 0 && activeAction !== idleAction) {
            switchAction(idleAction, 0);
          }
        }
      }
      
      renderer.render(scene, camera);
    }
    animate();
    
    // HANDLE WINDOW RESIZE
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
