<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Chickens with Gravity and Collision on All Levels</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #222;
      font-family: Arial, sans-serif;
    }
    canvas { display: block; }
    /* Control panel, crosshair, inventory, and position indicator styles */
    #control-panel {
      position: absolute; top: 10px; left: 10px; padding: 10px;
      background: rgba(20,20,20,0.8); color: #ddd; border-radius: 4px; z-index: 10;
    }
    #control-panel label { display: block; margin-bottom: 5px; }
    #crosshair {
      position: fixed; top: 50%; left: 50%;
      width: 20px; height: 20px; margin-left: -10px; margin-top: -10px;
      pointer-events: none; z-index: 9;
    }
    #crosshair:before, #crosshair:after {
      content: ""; position: absolute; background: white;
    }
    #crosshair:before { left: 9px; top: 0; width: 2px; height: 20px; }
    #crosshair:after  { top: 9px; left: 0; width: 20px; height: 2px; }
    #inventory {
      position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 5px; z-index: 11;
    }
    #inventory .slot {
      width: 50px; height: 50px; background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.2);
      display: flex; align-items: center; justify-content: center; cursor: pointer;
    }
    #inventory .slot.selected { border-color: yellow; }
    #inventory .slot img { width: 100%; height: 100%; object-fit: cover; }
    #positionIndicator {
      position: fixed; bottom: 10px; left: 10px; width: 80px; height: 200px;
      background: rgba(0,0,0,0.6); border: 1px solid #fff; color: #fff;
      font-size: 10px; padding: 5px; box-sizing: border-box; z-index: 12;
    }
    #positionMarker { position: absolute; left: 0; right: 0; height: 2px; background: red; }
    .tick { position: absolute; left: 0; right: 0; height: 1px; background: #fff; }
    #positionText {
      position: absolute; top: 5px; left: 5px; right: 5px;
      text-align: center; font-size: 10px; pointer-events: none; white-space: pre;
    }
  </style>
  <!-- Three.js and GLTFLoader -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>
<body>
  <div id="control-panel">
    <label><input type="checkbox" id="toggleGrid" /> Grid Visible</label>
    <label>Grid Transparency:
      <input type="range" id="gridOpacity" min="0" max="1" step="0.01" value="0.2" />
    </label>
    <label><input type="checkbox" id="toggleGravity" /> Gravity Enabled</label>
    <label><input type="checkbox" id="toggleWave" checked /> Wave Mode</label>
  </div>
  <div id="crosshair"></div>
  <div id="inventory">
    <!-- Slot 0: Grass tile -->
    <div class="slot selected" data-index="0">
      <img src="https://i.postimg.cc/J7fJ65py/102-6i2m-W1-H.png" alt="Grass Tile">
    </div>
    <!-- Slot 1: Dirt tile -->
    <div class="slot" data-index="1">
      <img src="https://i.postimg.cc/nrMdd80X/image.png" alt="Dirt Tile">
    </div>
    <!-- Slot 2: Chicken block -->
    <div class="slot" data-index="2">
      <img src="https://i.postimg.cc/3rmWR5ZR/15-6fb-H7-ZK.png" alt="Chicken">
    </div>
    <!-- Additional empty slots -->
    <div class="slot" data-index="3"></div>
    <div class="slot" data-index="4"></div>
    <div class="slot" data-index="5"></div>
    <div class="slot" data-index="6"></div>
    <div class="slot" data-index="7"></div>
    <div class="slot" data-index="8"></div>
    <div class="slot" data-index="9"></div>
    <div class="slot" data-index="10"></div>
    <div class="slot" data-index="11"></div>
    <div class="slot" data-index="12"></div>
    <div class="slot" data-index="13"></div>
    <div class="slot" data-index="14"></div>
    <div class="slot" data-index="15"></div>
    <div class="slot" data-index="16"></div>
    <div class="slot" data-index="17"></div>
    <div class="slot" data-index="18"></div>
    <div class="slot" data-index="19"></div>
  </div>
  <div id="positionIndicator">
    <div id="positionMarker"></div>
    <div id="positionText"></div>
  </div>

  <script>
    // --- Scene, Camera, Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 50000);
    camera.position.set(3276,2438,3159);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    // --- Load Chicken Model ---
    let loadedChickenModel = null;
    const gltfLoader = new THREE.GLTFLoader();
    gltfLoader.load(
      'https://raw.githack.com/Jscolorado7/Sandbox-Game/refs/heads/main/chicken.glb',
      function(gltf) {
        loadedChickenModel = gltf.scene;
        console.log("Chicken model loaded.");
      },
      undefined,
      function(error) { console.error("Error loading chicken:", error); }
    );

    // --- Lights ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(500,500,500);
    scene.add(directionalLight);

    // --- Terrain Setup ---
    const divisions = 100, cellSize = 50;
    const bottomY = -(divisions * cellSize)/2, topY = (divisions * cellSize)/2;
    const levelSpacing = 25 * cellSize;
    const baseHeights = [];
    for (let i = 0; i < divisions; i++) {
      baseHeights[i] = [];
      for (let j = 0; j < divisions; j++) {
        baseHeights[i][j] = Math.random()*2;
      }
    }
    function smoothHeights(map, passes = 2) {
      const w = map.length, h = map[0].length;
      for (let p = 0; p < passes; p++) {
        const temp = [];
        for (let i = 0; i < w; i++) {
          temp[i] = [];
          for (let j = 0; j < h; j++) {
            let sum = 0, count = 0;
            for (let di = -1; di <= 1; di++) {
              for (let dj = -1; dj <= 1; dj++) {
                const ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < w && nj >= 0 && nj < h) {
                  sum += map[ni][nj];
                  count++;
                }
              }
            }
            temp[i][j] = sum / count;
          }
        }
        for (let i = 0; i < w; i++) {
          for (let j = 0; j < h; j++) {
            map[i][j] = temp[i][j];
          }
        }
      }
    }
    smoothHeights(baseHeights, 2);

    // --- Build Ground (Instanced Mesh) ---
    const groundLevels = [];
    function buildAllGroundLevels() {
      let currentOffset = bottomY;
      let levelIndex = 0;
      while (currentOffset <= topY) {
        buildInstancedTerrainLevel(currentOffset, levelIndex);
        currentOffset += levelSpacing;
        levelIndex++;
      }
    }
    function buildInstancedTerrainLevel(offsetY, levelIndex) {
      const count = divisions * divisions;
      const texture = new THREE.TextureLoader().load("https://i.postimg.cc/J7fJ65py/102-6i2m-W1-H.png");
      const material = new THREE.MeshLambertMaterial({ map: texture });
      const geometry = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
      const instancedMesh = new THREE.InstancedMesh(geometry, material, count);
      const dummy = new THREE.Object3D();
      const transforms = [];
      const baseX = -(divisions * cellSize)/2, baseZ = -(divisions * cellSize)/2;
      let index = 0;
      for (let i = 0; i < divisions; i++) {
        for (let j = 0; j < divisions; j++) {
          const topYVal = baseHeights[i][j] * cellSize;
          const x = baseX + i * cellSize + cellSize/2;
          const z = baseZ + j * cellSize + cellSize/2;
          transforms.push({
            basePosition: new THREE.Vector3(x, offsetY + topYVal, z),
            baseY: topYVal,
            phase: (i + j) * 0.15
          });
          dummy.position.set(x, offsetY + topYVal, z);
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(index, dummy.matrix);
          index++;
        }
      }
      instancedMesh.instanceMatrix.needsUpdate = true;
      const lod = new THREE.LOD();
      lod.addLevel(instancedMesh, 0);
      scene.add(lod);
      groundLevels[levelIndex] = { lod, instancedMesh, transforms, offsetY };
    }
    buildAllGroundLevels();

    // --- Animate Ground Waves ---
    let waveTime = 0;
    const waveAmplitude = 20, waveFrequency = 1.0;
    function animateWaves(delta) {
      waveTime += delta;
      const dummy = new THREE.Object3D();
      for (const level of groundLevels) {
        const { instancedMesh, transforms, offsetY } = level;
        for (let i = 0; i < transforms.length; i++) {
          const { basePosition, baseY, phase } = transforms[i];
          const waveVal = waveAmplitude * Math.sin(waveFrequency * waveTime + phase);
          dummy.position.set(basePosition.x, offsetY + baseY + waveVal, basePosition.z);
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);
        }
        instancedMesh.instanceMatrix.needsUpdate = true;
      }
    }

    // --- Optional Grid ---
    const gridSize = divisions * cellSize;
    function createCubeGrid(size, divs, color, opacity) {
      const grid = new THREE.Group();
      const half = size / 2, step = size / divs;
      const material = new THREE.LineBasicMaterial({ color, opacity, transparent: true });
      for (let i = 0; i <= divs; i++) {
        let y = -half + i * step;
        for (let j = 0; j <= divs; j++) {
          let z = -half + j * step;
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute([-half, y, z, half, y, z], 3));
          grid.add(new THREE.Line(geometry, material));
        }
      }
      for (let i = 0; i <= divs; i++) {
        let x = -half + i * step;
        for (let j = 0; j <= divs; j++) {
          let z = -half + j * step;
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute([x, -half, z, x, half, z], 3));
          grid.add(new THREE.Line(geometry, material));
        }
      }
      for (let i = 0; i <= divs; i++) {
        let x = -half + i * step;
        for (let j = 0; j <= divs; j++) {
          let y = -half + j * step;
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute([x, y, -half, x, y, half], 3));
          grid.add(new THREE.Line(geometry, material));
        }
      }
      grid.userData.material = material;
      return grid;
    }
    const cubeGrid = createCubeGrid(gridSize, 20, 0x555555, 0.2);
    cubeGrid.visible = false;
    scene.add(cubeGrid);
    document.getElementById('toggleGrid').addEventListener('change', e => {
      cubeGrid.visible = e.target.checked;
    });
    document.getElementById('gridOpacity').addEventListener('input', e => {
      cubeGrid.userData.material.opacity = parseFloat(e.target.value);
    });

    // --- Toggles ---
    let gravityEnabled = false;
    document.getElementById('toggleGravity').addEventListener('change', e => {
      gravityEnabled = e.target.checked;
    });
    let waveEnabled = true;
    document.getElementById('toggleWave').addEventListener('change', e => {
      waveEnabled = e.target.checked;
      waveTime = 0;
    });

    // --- Blocks Storage ---
    const blocks = {};

    // --- Raycasting for Placement ---
    function getCandidateFromRay() {
      const raycaster = new THREE.Raycaster(camera.position, camera.getWorldDirection(new THREE.Vector3()));
      const groundCandidates = groundLevels.map(level => level.lod);
      const solids = groundCandidates.concat(Object.values(blocks));
      const hits = raycaster.intersectObjects(solids, true);
      if (!hits.length) return null;
      const hit = hits[0];
      const normal = hit.face.normal.clone();
      normal.transformDirection(hit.object.matrixWorld);
      if (hit.instanceId !== undefined) {
        let foundLevelIndex = null;
        for (let i = 0; i < groundLevels.length; i++) {
          if (groundLevels[i].lod.children.includes(hit.object)) {
            foundLevelIndex = i;
            break;
          }
        }
        if (foundLevelIndex !== null) {
          const transform = groundLevels[foundLevelIndex].transforms[hit.instanceId];
          const waveVal = waveAmplitude * Math.sin(waveFrequency * waveTime + transform.phase);
          const baseCenter = new THREE.Vector3(
            transform.basePosition.x,
            groundLevels[foundLevelIndex].offsetY + transform.baseY + waveVal,
            transform.basePosition.z
          );
          const candidate = baseCenter.clone().add(normal.multiplyScalar(cellSize));
          return { candidate, groundIndex: foundLevelIndex, instanceId: hit.instanceId };
        } else {
          const candidate = hit.point.clone().add(normal.multiplyScalar(cellSize));
          return { candidate, groundIndex: null, instanceId: null };
        }
      } else if (hit.object.userData.groundRef) {
        const gr = hit.object.userData.groundRef;
        const transform = groundLevels[gr.levelIndex].transforms[gr.instanceId];
        const waveVal = waveAmplitude * Math.sin(waveFrequency * waveTime + transform.phase);
        const baseCenter = new THREE.Vector3(
          transform.basePosition.x,
          groundLevels[gr.levelIndex].offsetY + transform.baseY + waveVal,
          transform.basePosition.z
        );
        const relativePos = hit.object.position.clone().sub(baseCenter);
        const candidate = baseCenter.clone().add(relativePos).add(normal.multiplyScalar(cellSize));
        return { candidate, groundIndex: gr.levelIndex, instanceId: gr.instanceId };
      }
      const candidate = hit.point.clone().add(normal.multiplyScalar(cellSize));
      return { candidate, groundIndex: null, instanceId: null };
    }

    function findGroundBelow(abovePos) {
      const rayStart = abovePos.clone();
      rayStart.y += 2000;
      const rayDir = new THREE.Vector3(0, -1, 0);
      const raycaster = new THREE.Raycaster(rayStart, rayDir);
      const groundLODs = groundLevels.map(level => level.lod);
      const hits = raycaster.intersectObjects(groundLODs, true);
      if (!hits.length) return null;
      const groundHit = hits[0];
      if (groundHit.instanceId === undefined) return null;
      let foundLevelIndex = null;
      for (let i = 0; i < groundLevels.length; i++) {
        if (groundLevels[i].lod.children.includes(groundHit.object)) {
          foundLevelIndex = i;
          break;
        }
      }
      if (foundLevelIndex === null) return null;
      const transform = groundLevels[foundLevelIndex].transforms[groundHit.instanceId];
      const waveVal = waveAmplitude * Math.sin(waveFrequency * waveTime + transform.phase);
      const baseCenter = new THREE.Vector3(
        transform.basePosition.x,
        groundLevels[foundLevelIndex].offsetY + transform.baseY + waveVal,
        transform.basePosition.z
      );
      return { groundRef: { levelIndex: foundLevelIndex, instanceId: groundHit.instanceId }, baseCenter };
    }

    // --- Global Box for Chicken Collision (to reduce lag) ---
    const chickenBBox = new THREE.Box3();

    // --- Chicken Collision Check (works across levels) ---
    function chickenCollisionCheck(b) {
      // Determine which tile (i,j) the chicken is over based on its x,z
      const halfRange = (divisions * cellSize) / 2;
      let i = Math.floor((b.position.x + halfRange) / cellSize);
      let j = Math.floor((b.position.z + halfRange) / cellSize);
      i = THREE.MathUtils.clamp(i, 0, divisions - 1);
      j = THREE.MathUtils.clamp(j, 0, divisions - 1);
      const index = i * divisions + j;
      
      // Loop over all ground levels to find the highest tile top that is below the chicken
      let candidateTileTop = -Infinity;
      for (let L = 0; L < groundLevels.length; L++) {
        const level = groundLevels[L];
        if (index < 0 || index >= level.transforms.length) continue;
        const transform = level.transforms[index];
        const waveVal = waveAmplitude * Math.sin(waveFrequency * waveTime + transform.phase);
        const tileTop = (level.offsetY + transform.baseY + waveVal) + (cellSize / 2);
        if (tileTop > candidateTileTop && tileTop <= b.position.y) {
          candidateTileTop = tileTop;
        }
      }
      if (candidateTileTop === -Infinity) return; // no candidate found

      // Reuse the global bounding box to avoid extra allocations.
      chickenBBox.setFromObject(b);
      const chickenBottom = chickenBBox.min.y;
      // If the chicken's bottom is below candidateTileTop + 1, push it up
      if (chickenBottom < candidateTileTop + 1) {
        const correction = (candidateTileTop + 1) - chickenBottom;
        b.position.y += correction;
        b.userData.velocityY = 0;
      }
    }

    // --- Build Outline ---
    const outlineGeom = new THREE.EdgesGeometry(new THREE.BoxGeometry(cellSize, cellSize, cellSize));
    const outlineMat = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const buildOutline = new THREE.LineSegments(outlineGeom, outlineMat);
    buildOutline.visible = false;
    scene.add(buildOutline);

    // --- Inventory Setup ---
    let selectedTile = 0;
    const inventorySlots = document.querySelectorAll("#inventory .slot");
    inventorySlots.forEach(slot => {
      slot.addEventListener("click", () => {
        selectedTile = parseInt(slot.getAttribute("data-index"));
        updateInventorySelection();
      });
    });
    function updateInventorySelection() {
      inventorySlots.forEach(slot => slot.classList.remove("selected"));
      const sel = document.querySelector(`#inventory .slot[data-index="${selectedTile}"]`);
      if (sel) sel.classList.add("selected");
    }
    document.addEventListener("wheel", e => {
      if (e.deltaY > 0) selectedTile = (selectedTile + 1) % 20;
      else selectedTile = (selectedTile + 19) % 20;
      updateInventorySelection();
    });

    // --- Movement, Gravity, Jump ---
    const moveSpeed = 200;
    const keys = {};
    let verticalVelocity = 0;
    const gravityVal = 400;
    const playerFootOffset = 30;
    const jumpSpeed = 260;
    let grounded = false;
    let lastSpaceTime = 0;
    const doubleTapThreshold = 300;

    // --- Build Mode Toggle ---
    let buildMode = false;
    document.addEventListener("keydown", e => {
      if (e.code === "Tab") {
        e.preventDefault();
        buildMode = !buildMode;
        return;
      }
      if (e.code === "Space") {
        if (!e.repeat) {
          const now = performance.now();
          if (now - lastSpaceTime < doubleTapThreshold) {
            gravityEnabled = !gravityEnabled;
            document.getElementById("toggleGravity").checked = gravityEnabled;
            if (!gravityEnabled) verticalVelocity = 0;
            lastSpaceTime = 0;
            e.preventDefault();
            return;
          }
          lastSpaceTime = now;
        }
        if (gravityEnabled && grounded && !e.repeat) {
          verticalVelocity = jumpSpeed;
          grounded = false;
        } else {
          keys["space"] = true;
        }
        e.preventDefault();
      } else {
        keys[e.key.toLowerCase()] = true;
      }
    });
    document.addEventListener("keyup", e => {
      if (e.code === "Space") keys["space"] = false;
      else keys[e.key.toLowerCase()] = false;
    });

    // --- Pointer Lock & Mouse Controls ---
    let pointerLocked = false;
    let yaw = 0, pitch = 0;
    const sensitivity = 0.002;
    document.addEventListener("pointerlockchange", () => {
      pointerLocked = (document.pointerLockElement === renderer.domElement);
    });
    renderer.domElement.addEventListener("mousedown", e => {
      if (!pointerLocked) {
        renderer.domElement.requestPointerLock();
        return;
      }
    });
    document.addEventListener("mousemove", e => {
      if (pointerLocked) {
        yaw -= e.movementX * sensitivity;
        pitch -= e.movementY * sensitivity;
        pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
        camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, "YXZ"));
      }
    });
    document.addEventListener("mouseup", e => {
      if (!pointerLocked) return;
      if (!buildMode) return;
      if (e.button === 0) { placeBlock(); }
      else if (e.button === 2) {
        const candidateData = getCandidateFromRay();
        if (candidateData && candidateData.candidate) {
          const raycaster = new THREE.Raycaster(camera.position, camera.getWorldDirection(new THREE.Vector3()));
          const groundLODs = groundLevels.map(l => l.lod);
          const solids = groundLODs.concat(Object.values(blocks));
          const hits = raycaster.intersectObjects(solids, true);
          if (hits.length) {
            const blockHit = hits[0];
            const key = blockHit.object.userData.key;
            if (key && blocks[key]) {
              scene.remove(blocks[key]);
              delete blocks[key];
            }
          }
        }
      }
    });
    renderer.domElement.addEventListener("contextmenu", e => e.preventDefault());

    // --- Position Indicator ---
    const indicator = document.getElementById("positionIndicator");
    const marker = document.getElementById("positionMarker");
    const positionText = document.getElementById("positionText");
    const levelsToShow = 5;
    const totalRange = (levelsToShow - 1) * levelSpacing + (cellSize * 2);
    const indicatorHeight = indicator.clientHeight;
    const scale = indicatorHeight / totalRange;
    for (let lvl = 0; lvl < levelsToShow; lvl++) {
      const tick = document.createElement("div");
      tick.className = "tick";
      tick.style.bottom = (lvl * levelSpacing * scale) + "px";
      indicator.appendChild(tick);
      const label = document.createElement("div");
      label.className = "label";
      label.style.position = "absolute";
      label.style.left = "0";
      label.style.right = "0";
      label.style.height = "10px";
      label.style.fontSize = "9px";
      label.style.textAlign = "left";
      label.style.bottom = (lvl * levelSpacing * scale) + "px";
      label.style.color = "#fff";
      label.textContent = `Lvl ${lvl}`;
      indicator.appendChild(label);
    }

    // --- Place Block ---
    function placeBlock() {
      const data = getCandidateFromRay();
      if (!data || !data.candidate) return;
      const groundBelow = findGroundBelow(data.candidate);
      if (!groundBelow) return;
      const { groundRef, baseCenter } = groundBelow;
      const x = data.candidate.x, y = data.candidate.y, z = data.candidate.z;
      const key = `${x}_${y}_${z}`;
      if (blocks[key]) return;
      let newBlock;
      if (selectedTile === 2) {
        // Place Chicken: Start above ground so gravity takes over.
        if (!loadedChickenModel) {
          console.warn("Chicken model not loaded yet.");
          return;
        }
        newBlock = loadedChickenModel.clone(true);
        scene.add(newBlock);
        // Scale and shift so that the modelâ€™s local bottom is at y=0.
        const bbox1 = new THREE.Box3().setFromObject(newBlock);
        const size = new THREE.Vector3();
        bbox1.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z);
        const scaleFactor = cellSize / maxDim;
        newBlock.scale.set(scaleFactor, scaleFactor, scaleFactor);
        newBlock.updateMatrixWorld(true);
        const bbox2 = new THREE.Box3().setFromObject(newBlock);
        const offset = -bbox2.min.y;
        newBlock.position.y += offset;
        newBlock.updateMatrixWorld(true);
        // Place horizontally.
        newBlock.position.x = x;
        newBlock.position.z = z;
        // Get current ground top from the level the candidate came from.
        const currentGroundTop = groundBelow.baseCenter.y + (cellSize / 2);
        // Place the chicken 50 units above the ground so gravity can act.
        newBlock.position.y = currentGroundTop + 50;
        // Initialize vertical velocity for the chicken.
        newBlock.userData.velocityY = 0;
        newBlock.isChicken = true;
        const spd = 10 + Math.random() * 5;
        const angle = Math.random() * Math.PI * 2;
        newBlock.chickenVelocity = new THREE.Vector3(Math.cos(angle)*spd, 0, Math.sin(angle)*spd);
        newBlock.nextVelocityChangeTime = performance.now() + 2000 + Math.random()*3000;
      } else {
        // Normal block: Grass (slot 0) or Dirt (slot 1)
        let textureUrl;
        if (selectedTile === 0) textureUrl = "https://i.postimg.cc/J7fJ65py/102-6i2m-W1-H.png";
        else if (selectedTile === 1) textureUrl = "https://i.postimg.cc/nrMdd80X/image.png";
        else textureUrl = "https://i.postimg.cc/J7fJ65py/102-6i2m-W1-H.png";
        const geom = new THREE.BoxGeometry(cellSize, cellSize, cellSize);
        const mat = new THREE.MeshLambertMaterial({ map: new THREE.TextureLoader().load(textureUrl) });
        newBlock = new THREE.Mesh(geom, mat);
        newBlock.position.set(x, y, z);
        scene.add(newBlock);
        newBlock.userData.relativeOffset = new THREE.Vector3(x, y, z).sub(baseCenter);
      }
      newBlock.userData.key = key;
      newBlock.userData.groundRef = groundRef;
      blocks[key] = newBlock;
    }

    // --- Main Animation Loop ---
    let prevTime = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const delta = (now - prevTime) / 1000;
      prevTime = now;

      // Camera Movement
      const direction = new THREE.Vector3();
      if (keys["w"]) { const f = new THREE.Vector3(); camera.getWorldDirection(f); direction.add(f); }
      if (keys["s"]) { const b = new THREE.Vector3(); camera.getWorldDirection(b); direction.sub(b); }
      if (keys["a"] || keys["d"]) {
        const f = new THREE.Vector3(); camera.getWorldDirection(f);
        const left = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), f).normalize();
        if (keys["a"]) direction.add(left);
        if (keys["d"]) direction.sub(left);
      }
      if (!gravityEnabled) {
        if (keys["e"] || keys["space"]) direction.y += 1;
        if (keys["c"]) direction.y -= 1;
      }
      if (direction.length() > 0) {
        direction.normalize();
        let speed = moveSpeed;
        if (keys["shift"]) speed *= 2;
        camera.position.add(direction.multiplyScalar(speed * delta));
      }

      // Camera Gravity
      if (gravityEnabled) {
        verticalVelocity -= gravityVal * delta;
        camera.position.y += verticalVelocity * delta;
      }

      // Animate Ground Waves
      if (waveEnabled) { animateWaves(delta); }

      // Build Outline
      if (buildMode) {
        const data = getCandidateFromRay();
        if (data && data.candidate) {
          buildOutline.visible = true;
          buildOutline.position.copy(data.candidate);
        } else { buildOutline.visible = false; }
      } else { buildOutline.visible = false; }

      // Update Blocks
      for (const k in blocks) {
        const b = blocks[k];
        if (b.isChicken) {
          // Horizontal random walk
          b.position.x += b.chickenVelocity.x * delta;
          b.position.z += b.chickenVelocity.z * delta;
          const spd = b.chickenVelocity.length();
          if (spd > 0.01) {
            // If model appears reversed, try swapping .sub() with .add()
            b.lookAt(b.position.clone().sub(b.chickenVelocity));
          }
          if (now > b.nextVelocityChangeTime) {
            if (Math.random() < 0.3) {
              b.chickenVelocity.set(0, 0, 0);
              b.nextVelocityChangeTime = now + 1000 + Math.random()*1000;
            } else {
              const newSpd = 10 + Math.random()*5;
              const newAng = Math.random()*Math.PI*2;
              b.chickenVelocity.set(Math.cos(newAng)*newSpd, 0, Math.sin(newAng)*newSpd);
              b.nextVelocityChangeTime = now + 2000 + Math.random()*3000;
            }
          }
          // Apply gravity to chicken
          if (b.userData.velocityY === undefined) b.userData.velocityY = 0;
          b.userData.velocityY -= gravityVal * delta;
          b.position.y += b.userData.velocityY * delta;
          // Collision check: adjust chicken so its bottom is 1 unit above the ground
          chickenCollisionCheck(b);
        } else if (b.userData.groundRef && b.userData.relativeOffset) {
          const gr = b.userData.groundRef;
          const transform = groundLevels[gr.levelIndex].transforms[gr.instanceId];
          const waveVal = waveAmplitude * Math.sin(waveFrequency * waveTime + transform.phase);
          const currentGroundCenter = new THREE.Vector3(
            transform.basePosition.x,
            groundLevels[gr.levelIndex].offsetY + transform.baseY + waveVal,
            transform.basePosition.z
          );
          b.position.copy(currentGroundCenter.clone().add(b.userData.relativeOffset));
        }
      }

      // Update Position Indicator
      let markerY = (camera.position.y - bottomY) * scale;
      markerY = Math.max(0, Math.min(indicator.clientHeight, markerY));
      marker.style.bottom = markerY + "px";
      const currentLevel = Math.floor((camera.position.y - bottomY) / levelSpacing);
      positionText.textContent =
        `X: ${camera.position.x.toFixed(0)}\n` +
        `Y: ${camera.position.y.toFixed(0)}\n` +
        `Z: ${camera.position.z.toFixed(0)}\n` +
        `Lvl: ${currentLevel}`;

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
